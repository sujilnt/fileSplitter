name:spkAhuOnAndUnoccupied
func
ruleReady
src:
  /*
    AHU is on and site is unoccupied.
  
    Params:
    - on: rec with `fan and cmd` tags
    - dates: any valid `hisRead` date range
    - threshold: number of hours AHU must be on outside
        of occupied time before we consider generating a spark
  
    Returns:
      - spark periods
  */
  
  
  (thePoints, dates, threshold: 0h) => do
  
    // get periods when lights are on
    on: hisRead(thePoints, dates).hisFindPeriods(v => v == 1)
  
    // get unoccupied periods
    unoccupied: toOccupied(thePoints).hisRead(dates).hisFindPeriods(v => not v)
     
    // compute intersection and filter out periods under threshold
    faults: hisPeriodIntersection([on, unoccupied]).hisFindAll(p => p != na() and p > threshold)
  
  
  end
---
name:tagstoadd
func
src:
  () => do
      logCat: "rule"
       dict:{
        //"oat": r".*[Oo]utside[Aa]ir[Tt]e?mp.*",
        //"temp": r".*[Tt]e?mp.*",
        //"doorHeater": r".*[Dd]oor[Hh]eater.*",
        //"setpoint": r".*[Ss][Pp]",
        //"return": r".*[Rr]eturn.*",
        //"flow": r".*[Ff]low.*",
        //"discharge": r".*[Ss]up.*",
        //"fan": r".*[Ff]an.*",
        //"cmd": r".*[Ee]nable.*",
        //"cmd": r".*[Oo][Pp]",
        //"valve": r".*[Vv][al]?ve.*",
        //"heating": r".*[Hh][Tt][Gg].*",
        //"heating": r".*[Hh][Tt][Rr].*",
        //"temp": r".*[Ss]pace.*",
        "damper": r".*[Dd]amper.*",
        
        
        
       };
       
       mappedval: each(dict,(value, name)=>do
           nametostring: name.toStr();
           filteredList:readAll(point and not name).findAll(rec => reMatches(value, rec->dis.toStr)).toGrid()
           
           // always need to replace or change the name of the tag in next line,comment out the out other tags in the dict example in line 3  
           // =>filteredList.addCol("diffs", r => r.diff({"tagName in strings ":marker()})).colToList("diffs").commit
                
           filteredList.addCol("diffs", r => r.diff({"damper":marker()})).colToList("diffs").commit // Commit them all 
           //filteredList.addCol("diffs", r => r.diff({hisMode:"cov"})).colToList("diffs").commit // Gives back a list of 'diff's
       end)
  end
  
---
name:spkHighTemp
func
src:
  /***
  spark when temp is above threshhold
  
  Axon filter: setpoint
  ****/
  
  (point, dates, threshold: 25°C) => do
    // read point history
    his: point.hisRead(dates)
    
    // analyze the point
    // return true when the CHW temp is under a value
    // return a grid of timestap:duration values
    his = his.hisRollup(avg, 30min) 
    
    his.hisFindPeriods v => v != null and v > threshold
  end
---
name:zzimpPlant
func
src:
  (site) => do
    // s is site to import the equipment to
   
      plantNameToTags: {
      r"ElecMeter":  {elec, meter, siteMeter},
      r"RTU-(\d+)":  {ahu},
      r"AHU(\d+)":  {ahu},
      r"CHW": {chiller}
    }   
      applyTagsByRegex: (mapping, name, tags) => do
        // check for every match in mapping dict of regex:tags
        mapping.each((tagsToAdd,regex) => do
        // we had a match, walk thru each tagToAdd and add it to tags; 
        // if the tag value is a function then call the function with reGroups
        if (regex.reMatches(name)) do
          tagsToAdd.each((v, n) => do
            if (v.isFunc()) 
              v = v(reGroups(regex, name))
              tags = tags.set(n, v)
            end)
          end
        end)
        // return potentially updated tags
        return tags
      end
    // function to map point list to equip records
    mapPlant: () => do
      // since multiple points might map to one piece of equip,
      // we create an accumulator map of dis-to-record
      acc: {}
        importedPoints.each row => do
        // parse equip name from path column
        plantName: row->axHistoryId.split("/")[-2].split("_")[-1]
        //   get the site ref     
        site: read(site and dis == site)
        // map string cells to typed tags
        tags: { 
          dis: site->dis + "_" + plantName,
          siteRef: site->id,
          plant,
        }
        // check if equip name matches one of our regular expressions
        tags = applyTagsByRegex(plantNameToTags, plantName, tags)
        acc = acc.set(tags->dis, tags)
      end
      return acc.vals
    end
    // function to import the equips
    importPlant: () => do
      mapPlant().each row => do 
        // log an info message
        logInfo("import", "Add equip: " + row->dis)
        // filter out any null or empty string tags
        row = row.findAll x => x != null and x != ""
        // check if record esists if not add as new record to the database
        if (read(dis == row["dis"]  and siteRef  == row["siteRef"] ,false) == null) 
           commit(diff(null, row, {add}))
      end    
    end  
    // import files we will use
    hc: read(haystackConn)->id
    importedPoints: hc.haystackReadAll(his and kind == "Number").findAll(row => row->dis.contains(site))
    
    importPlant()       // map points CSV and add equip recs
  
  
  end
  
---
name:spkInverterAbove80
func
src:
  /***
  spark when Inverter setpoint is above threshhold
  
  Axon filter: setpoint
  ****/
  
  (setpoint, dates, threshold: 80) => do
    // read point history
    his: setpoint.hisRead(dates)
    
    // analyze the point
    // return true when sp is above threshold
    // return a grid of timestap:duration values
    his = his.hisRollup(avg, 30min) 
    
    his.hisFindPeriods v => v != null and v > threshold
  end
---
name:obTagScript
func
src:
  /*
      dictinput -> it must be dictionary that is used for querying 
       ex:- dict:{"oat": r".*[Oo]utside[Aa]ir[Tt]e?mp.*",
        "temp": r".*[Tt]e?mp.*",
       };
       
      markerName -> it the tag you want to add  ex: marker()  
      
  */
  
  (dictInput,markerName) => do
    dict: dictInput;
    tagValues: markerName;
    if(dictInput.isEmpty) return "input parameter Object are wrong or empty !"
    // or else dictInput is not empty then .... 
    createdictname: ((tagName,tagValues)=> do 
            return {}.set(tagName,tagValues);
       end);  
       mappedval: each(dict,(value, name)=>do
           diffObj:createdictname(name,tagValues); // function that create a tag for you based on "name" from dictinput and markerName.
           filteredList:readAll(point and not name).findAll(rec => reMatches(value, rec->dis.toStr)).toGrid() // ex-> readAll(point).findAll(rec => reMatches(r".*[Oo]utside[Aa]ir[Tt]e?mp.*", rec->dis.toStr)).toGrid()
           filteredList.addCol("diffs", (r) => r.diff(diffObj)).colToList("diffs").commit  // Commit them all
           //filteredList.addCol("diffs", r => r.diff(diffObj})).colToList("diffs") // Gives back a list of 'diff's , only use for test purpos
       end);
       echo("tags added successfully");
  end
---
name:zzzimportEquip
func
src:
  (site) => do
    // s is site to import the equipment to
   
      equipNameToTags: {
      r"ElecMeter":  {elec, meter, siteMeter},
      r"RTU-(\d+)":  {ahu},
      r"AHU(\d+)":  {ahu},
      r"CHW": {chiller}
    }   
      applyTagsByRegex: (mapping, name, tags) => do
        // check for every match in mapping dict of regex:tags
        mapping.each((tagsToAdd,regex) => do
        // we had a match, walk thru each tagToAdd and add it to tags; 
        // if the tag value is a function then call the function with reGroups
        if (regex.reMatches(name)) do
          tagsToAdd.each((v, n) => do
            if (v.isFunc()) 
              v = v(reGroups(regex, name))
              tags = tags.set(n, v)
            end)
          end
        end)
        // return potentially updated tags
        return tags
      end
    // function to map point list to equip records
    mapEquips: () => do
      // since multiple points might map to one piece of equip,
      // we create an accumulator map of dis-to-record
      acc: {}
        importedPoints.each row => do
        // parse equip name from path column
        equipName: row->axHistoryId.split("/")[-2].split("_")[-1]
        //   get the site ref     
        site: read(site and dis == site)
        // map string cells to typed tags
        tags: { 
          dis: site->dis + " " + equipName,
          siteRef: site->id,
          equip,
        }
        // check if equip name matches one of our regular expressions
        tags = applyTagsByRegex(equipNameToTags, equipName, tags)
        acc = acc.set(tags->dis, tags)
      end
      return acc.vals
    end
    // function to import the equips
    importEquips: () => do
      mapEquips().each row => do 
        // log an info message
        logInfo("import", "Add equip: " + row->dis)
        // filter out any null or empty string tags
        row = row.findAll x => x != null and x != ""
        // check if record esists if not add as new record to the database
        if (read(dis == row["dis"]  and siteRef  == row["siteRef"] ,false) == null) 
           commit(diff(null, row, {add}))
      end    
    end  
    // import files we will use
    hc: read(haystackConn)->id
    importedPoints: hc.haystackReadAll(his and kind == "Number").findAll(row => row->dis.contains(site))
    
    importEquips()       // map points CSV and add equip recs
  
  
  end
---
name:equipToPoints
func
src:
  /*
   This function overrides standard 'site::equipToPoints' function
   and illustrates how you can customize the points displayed by
   by apps such as the SiteApp.  We demo two techniques in this
   example.  First we include every "site-wide" point with the 'sitePoint'
   tag.  Secondly for nested equips, we look for the 'summary' tag
   to show select points in the parent equip.
  */
  (equip) => do
     readAll(point and
       ((equipRef==equip->id) or                     // direct points
       (sitePoint and siteRef==equip->siteRef) or    // site-wide points
       (equipRef->equipRef==equip->id and summary))) // summary points of nested equip
  end
---
name:boolConversion
func
src:
  () => do
    tagswithENable: readAll(enable and kind=="Number")
    tagswithENable = tagswithENable.each((row)=>do
    rowid: row["id"].toStr;
    newId:parseRef(rowid, dis: row["dis"], checked: true); 
    hisRewrite(readLink(newId), (val,ts) => if(val < 0.5)[ ts, false] else if(val > 0.5 or val == 0.5)[ts, true] else [ts,val])
    end)
  end
---
name:importPoints
func
src:
  (siteSel) => do
      acc:{}
    //s is site to import points to
    
      // function used to add our new records
    addRec: (msg, tags) => do
  
      // log an info message
      logInfo("import", msg)
  
      // filter out any null or empty string tags
      tags = tags.findAll x => x != null and x != ""
      
            // check if record esists if not add as new record to the database
        if (read(navName == tags["navName"]  and siteRef  == tags["siteRef"] and equipRef == tags["equipRef"],false) == null)
        do
      commit(diff(null, tags, {add}))
  end
    end
    
    
  
    pointNameToTags: {
      r"Demand":           {power, sensor},
      r"Consumption":      {energy, sensor},
      r"SupplyFan":        {supply, air, fan, cmd},
      r"SupplyA?i?r?Temp": {supply, air, temp, sensor},
      r"ReturnA?i?r?Temp": {"return", air, temp, sensor},
      r"FanSpeed":         {fan, air, speed},
      r"RoomStatus":       {room, status},
      r"Fanstatus":        {air,fan, sensor},
      r"Schedule":          {cmd},
      r"Control":          {cmd},
      r"Boiler1?Temp": {flow,temp, sensor},
      r"HW Return Temp": {"return", temp, sensor},    
      r"HW Supply Temp": {flow, temp, sensor},    
      r"HW SP": {temp, cmd, setpoint}, 
      r"Boiler1?Run": {sensor},    
      r"Boiler1?En": {cmd},
      r"FlowTemp": {flow, temp, sensor},
      r"$Delta Pressure": {pressure, sensor},
      r"ReturnTemp": {"return", temp, sensor},
      r"$Delta Pressure SP": {pressure, cmd},
      r"$Ena?b?l?e?": {cmd},
      r"$Flow": {sensor},
      r"$VFD": {speed, cmd},
      r"Boiler\s1?\sEn": {cmd},
      r"Boiler\s1?\sRun": {sensor},
      r"Chiller\s1?\sEn": {cmd},
      r"chiller\s1?\sRun": {sensor},    
      r"Cool-(\d+)":       {cool, stage:(groups)=>groups[1].parseNumber, cmd},
      r"Heat-(\d+)":       {heat, stage:(groups)=>groups[1].parseNumber, cmd},
    }
        applyTagsByRegex: (mapping, name, tags) => do
        // check for every match in mapping dict of regex:tags
        mapping.each((tagsToAdd,regex) => do
        // we had a match, walk thru each tagToAdd and add it to tags; 
        // if the tag value is a function then call the function with reGroups
        if (regex.reMatches(name)) do
          tagsToAdd.each((v, n) => do
            if (v.isFunc()) 
              v = v(reGroups(regex, name))
              tags = tags.set(n, v)
            end)
          end
        end)
        // return potentially updated tags
        return tags
      end
  
    
  
    // function to map point list to point records
    mapPoints: () => do
  
      pointsFile.each row => do
  
        // parse point name from path column
        plantName: row->axHistoryId.split("/")[1].split("_")[1]
        equipName: row->axHistoryId.split("/")[1].split("_")[1]
        pointName: row->axHistoryId.split("/")[-1]
        
        //pointName: row->dis
  
        // associate with site via storeNum
        site: read(site and dis == siteSel)
        
              // associate with equip via dis
        //plant: read(plant and dis == plantName)
        plant: read(siteRef->dis == siteSel and plant and navName == plantName)
  
        // associate with equip via dis
       // equip: read(equip and dis == equipName)
       equip : read(siteRef->dis == siteSel and plantRef->navName == plantName and equip and navName == equipName)
  
  
        // map string cells to typed tags
        //f: row[unit]
        //    if(row[unit] != null) echo(row[unit])
        tags: {
        //  dis:      pointName,
          navName:  pointName,
          disMacro: `\$equipRef \$navName`.toStr(),
          siteRef:  site->id,
          plantRef: plant->id,
          equipRef: equip->id,
          kind:     row->kind,
          tz:       site->tz,
          point,
          his,
          haystackHis: row->id.toStr,
          haystackConnRef: read(haystackConn)->id,
          connRef: read(haystackConn)->id,
          unit: if(row.has("unit")) row->unit
        }
  
        // if kind is Number, we must have unit column
  //      if (tags->kind == "Number")
    //     tags = tags.set("unit", parseUnit(row->unit))
  
        // check if point name matches one of our regular expressions
        tags = applyTagsByRegex(pointNameToTags, pointName, tags)
        acc = acc.set(tags->navName,tags)
      end
      return acc.vals
    end 
    
    // function to import the points
    importPoints: () => do
      //echo(mapPoints())
      mapPoints().each row => addRec("Add point: " + row->navName, row)
    end  
   
    // import files we will use
    hc: read(haystackConn)->id
    // pointsFile: hc.haystackReadAll(point and cur)
     
        pointsFile: hc.haystackReadAll(his and kind == "Number").findAll(row => row->dis.contains(siteSel))
    importPoints()       // map points CSV and add points recs
  //  readAll(imported)    // return everything we added
  acc.vals
  //pointsFile
  //hc
  
  end
  
  
  
---
name:zzzimportPoints
func
src:
  (site) => do
      acc:{}
    //s is site to import points to
    
      // function used to add our new records
    addRec: (msg, tags) => do
  
      // log an info message
      logInfo("import", msg)
  
      // filter out any null or empty string tags
      tags = tags.findAll x => x != null and x != ""
      
            // check if record esists if not add as new record to the database
        if (read(dis == tags["dis"]  and siteRef  == tags["siteRef"] and equipRef == tags["equipRef"],false) == null) do
      commit(diff(null, tags, {add}))
  end
    end
    
    
  
    pointNameToTags: {
      r"Demand":           {power, sensor},
      r"Consumption":      {energy, sensor},
      r"SupplyFan":        {supply, air, fan, cmd},
      r"SupplyA?i?r?Temp": {supply, air, temp, sensor},
      r"ReturnA?i?r?Temp": {"return", air, temp, sensor},
      r"FanSpeed":         {fan, air, speed},
      r"RoomStatus":       {room, status},
      r"Fanstatus":        {air,fan, sensor},
      r"Schedule":          {cmd},
      r"Control":          {cmd},
      r"Boiler1?Temp": {flow,temp, sensor},
      r"HW Return Temp": {"return", temp, sensor},    
      r"HW Supply Temp": {flow, temp, sensor},    
      r"HW SP": {temp, cmd, setpoint}, 
      r"Boiler1?Run": {sensor},    
      r"Boiler1?En": {cmd},
      r"FlowTemp": {flow, temp, sensor},
      r"$Delta Pressure": {pressure, sensor},
      r"ReturnTemp": {"return", temp, sensor},
      r"$Delta Pressure SP": {pressure, cmd},
      r"$Ena?b?l?e?": {cmd},
      r"$Flow": {sensor},
      r"$VFD": {speed, cmd},
      r"Boiler\s1?\sEn": {cmd},
      r"Boiler\s1?\sRun": {sensor},
      r"Chiller\s1?\sEn": {cmd},
      r"chiller\s1?\sRun": {sensor},    
      r"Cool-(\d+)":       {cool, stage:(groups)=>groups[1].parseNumber, cmd},
      r"Heat-(\d+)":       {heat, stage:(groups)=>groups[1].parseNumber, cmd},
    }
        applyTagsByRegex: (mapping, name, tags) => do
        // check for every match in mapping dict of regex:tags
        mapping.each((tagsToAdd,regex) => do
        // we had a match, walk thru each tagToAdd and add it to tags; 
        // if the tag value is a function then call the function with reGroups
        if (regex.reMatches(name)) do
          tagsToAdd.each((v, n) => do
            if (v.isFunc()) 
              v = v(reGroups(regex, name))
              tags = tags.set(n, v)
            end)
          end
        end)
        // return potentially updated tags
        return tags
      end
  
    
  
    // function to map point list to point records
    mapPoints: () => do
  
      pointsFile.each row => do
  
        // parse point name from path column
        equipName: row->axHistoryId.split("/")[-2].split("_")[-1]
        pointName: row->axHistoryId.split("/")[-1]
        //pointName: row->dis
  
        // associate with site via storeNum
        site: read(site and dis == site)
  
        // associate with equip via dis
        equip: read(equip and dis == site->dis + " " + equipName)
  
        // map string cells to typed tags
        //f: row[unit]
        //    if(row[unit] != null) echo(row[unit])
        tags: {
          dis:      site->dis + " " + equipName + " " + pointName,
          siteRef:  site->id,
          equipRef: equip->id,
          kind:     row->kind,
          tz:       site->tz,
          point,
          his,
          haystackHis: row->id.toStr,
          haystackConnRef: read(haystackConn)->id,
          connRef: read(haystackConn)->id,
          unit: if(row.has("unit")) row->unit
        }
  
        // if kind is Number, we must have unit column
  //      if (tags->kind == "Number")
    //     tags = tags.set("unit", parseUnit(row->unit))
  
        // check if point name matches one of our regular expressions
        tags = applyTagsByRegex(pointNameToTags, pointName, tags)
        acc = acc.set(tags->dis,tags)
      end
      return acc.vals
    end 
    
    // function to import the points
    importPoints: () => do
      //echo(mapPoints())
      mapPoints().each row => addRec("Add point: " + row->dis, row)
    end  
   
    // import files we will use
    hc: read(haystackConn)->id
    // pointsFile: hc.haystackReadAll(point and cur)
     
        pointsFile: hc.haystackReadAll(his and kind == "Number").findAll(row => row->dis.contains(site))
    importPoints()       // map points CSV and add points recs
  //  readAll(imported)    // return everything we added
  acc.vals
  end
  
  
  
---
name:vishalboilertest
func
src:
  () => do
    "Hello world!"
  end
  
---
name:obMarkerTagDict
func
src:
  () => do
    dict:{
        oat: r".*[Oo]utside[Aa]ir[Tt]e?mp.*",
        temp: r".*[Tt]e?mp.*",
        doorHeater: r".*[Dd]oor[Hh]eater.*",
        setpoint: r".*[Ss][Pp]",
        return: r".*[Rr]eturn.*",
        flow: r".*[Ff]low.*",
        discharge: r".*[Ss]up.*",
        fan: r".*[Ff]an.*",
        cmd: r".*[Ee]nable.*",
        cmd: r".*[Oo][Pp]",
        valve: r".*[Vv]alve.*",
        heating: r".*[Hh][Tt][Gg].*",
        heating: r".*[Hh][Tt][Rr].*",
        temp: r".*[Ss]pace.*",
        damper: r".*[Dd]amper.*",
        heat: r".*[Bb]urner.*",
        exhaust: r".*Ext.*",
        exhaust: r".*EF.*",
        speed: r".*[Ss][Pp][Dd].*",
        speed: r".*[Ss]peed.*",
        boiler: r".*[Bb]oiler.*",
        pump: r".*[Pp]ump.*",
        boiler: r".*[Bb]lr.*",
        pressure: r".*[Pp]res.*",
        chilled: r".*[Cc]hil.*",
        cmd: r".*[Ss]ignal.*",
              
       };
       obTagScript(dict,marker());
  end
---
name:importPlant
func
src:
  (siteSel) => do
    // s is site to import the equipment to
   acc: {}
      plantNameToTags: {
      r"ElecMeter":  {elec, meter, siteMeter},
      r"RTU-(\d+)":  {ahu},
      r"AHU(\d+)":  {ahu},
      r"CHW": {chiller}
    }   
      applyTagsByRegex: (mapping, name, tags) => do
        // check for every match in mapping dict of regex:tags
        mapping.each((tagsToAdd,regex) => do
        // we had a match, walk thru each tagToAdd and add it to tags; 
        // if the tag value is a function then call the function with reGroups
        if (regex.reMatches(name)) do
          tagsToAdd.each((v, n) => do
            if (v.isFunc()) 
              v = v(reGroups(regex, name))
              tags = tags.set(n, v)
            end)
          end
        end)
        // return potentially updated tags
        return tags
      end
    // function to map point list to equip records
    mapPlant: () => do
      // since multiple points might map to one piece of equip,
      // we create an accumulator map of dis-to-record
      
        importedPoints.each row => do
        // parse equip name from path column
        plantName: row->axHistoryId.split("/")[-2].split("_")[-1]
        //   get the site ref     
        site: read(site and dis == siteSel)
        // map string cells to typed tags
        tags: { 
          navName: plantName,
          disMacro:`\$siteRef \$navName`.toStr(),
          siteRef: site->id,
          plant,
        }
        // check if equip name matches one of our regular expressions
        tags = applyTagsByRegex(plantNameToTags, plantName, tags)
        acc = acc.set(tags->navName, tags)
      end
      return acc.vals
    end
    // function to import the equips
    importPlant: () => do
      mapPlant().each row => do 
        // log an info message
        logInfo("import", "Add equip: " + row->navName)
        // filter out any null or empty string tags
        row = row.findAll x => x != null and x != ""
        // check if record esists if not add as new record to the database
        if (read(navName == row["navName"]  and siteRef  == row["siteRef"] ,false) == null) 
           commit(diff(null, row, {add}))
      end    
    end  
    // import files we will use
    hc: read(haystackConn)->id
    importedPoints: hc.haystackReadAll(his and kind == "Number").findAll(row => row->dis.contains(siteSel))
    
    importPlant()       // map points CSV and add equip recs
  acc.vals
  
  end
---
name:importEquip
func
src:
  (siteSel) => do
  
     acc:{}
    // s is site to import the equipment to
      addRec: (msg, tags) => do
  
      // log an info message
      logInfo("import", msg)
  
      // filter out any null or empty string tags
      tags = tags.findAll x => x != null and x != ""
      
            // check if record esists if not add as new record to the database
       if (read(navName == tags["navName"]  and siteRef  == tags["siteRef"] and plantRef == tags["plantRef"],false) == null) 
        do
      commit(diff(null, tags, {add}))
  end
    end
    
    
   
      plantNameToTags: {
      r"ElecMeter":  {elec, meter, siteMeter},
      r"RTU-(\d+)":  {ahu},
      r"AHU(\d+)":  {ahu},
      r"CHW": {chiller}
    }   
      applyTagsByRegex: (mapping, name, tags) => do
        // check for every match in mapping dict of regex:tags
        mapping.each((tagsToAdd,regex) => do
        // we had a match, walk thru each tagToAdd and add it to tags; 
        // if the tag value is a function then call the function with reGroups
        if (regex.reMatches(name)) do
          tagsToAdd.each((v, n) => do
            if (v.isFunc()) 
              v = v(reGroups(regex, name))
              tags = tags.set(n, v)
            end)
          end
        end)
        // return potentially updated tags
        return tags
      end
    // function to map point list to equip records
  
    // function to map point list to point records
    mapPoints: () => do
    //  acc:{}
      pointsFile.each row => do
  
        // parse point name from path column
        plantName: row->axHistoryId.split("/")[-2].split("_")[-1]
        equipName: row->axHistoryId.split("/")[-2].split("_")[-1]
        //pointName: row->dis
  
        // associate with site via storeNum
        site: read(site and dis == siteSel)
  
        // associate with equip via dis
     plant: read(siteRef->dis == siteSel and plant and navName == plantName)
  
  
  
        // map string cells to typed tags
        //f: row[unit]
        //    if(row[unit] != null) echo(row[unit])
        tags: {
          navName:      equipName,
          disMacro: `\$plantRef \$navName`.toStr(),
          siteRef:  site->id,
          plantRef: plant->id,
          equip,
        }
  
        // if kind is Number, we must have unit column
  //      if (tags->kind == "Number")
    //     tags = tags.set("unit", parseUnit(row->unit))
  
        // check if point name matches one of our regular expressions
        tags = applyTagsByRegex(plantNameToTags, equipName, tags)
        acc = acc.set(tags->navName,tags)
      end
      return acc.vals
    end 
    
    // function to import the points
    importEquipsL: () => do
      //echo(mapPoints())
      mapPoints().each row => addRec("Add equip: " + row->navName, row)
    end  
   
    // import files we will use
    hc: read(haystackConn)->id
    // pointsFile: hc.haystackReadAll(point and cur)
     
        pointsFile: hc.haystackReadAll(his and kind == "Number").findAll(row => row->dis.contains(siteSel))
    importEquipsL()       // map points CSV and add points recs
  //  readAll(imported)    // return everything we added
  acc.vals
  end
---
name:spkTempAbove27Occupied
func
src:
  () => do
    "Hello world!"
  end
  
---
name:spkPumpsOnBoilerOff
func
src:
  (theEquip, date) => do
  
  
  pumpOn: read(boiler and pump and equipRef==theEquip->id)
      .hisRead(date)
      .hisFindPeriods(v => v > 0)
      
  
  boilerOff: read(boiler and enable and equipRef==theEquip->id)
      .hisRead(date)
      .hisFindPeriods(v => v == 0)
      
  
  faults: hisPeriodIntersection([pumpOn, boilerOff])
    
  
  end
---
name:spkSetpointAbove21
func
src:
  /***
  spark when setpoint temp is above threshhold
  
  Axon filter: setpoint
  ****/
  
  (setpoint, dates, threshold: 21°C) => do
    // read point history
    his: setpoint.hisRead(dates)
    
    // analyze the point
    // return true when sp is above threshold
    // return a grid of timestap:duration values
    his = his.hisRollup(avg, 30min) 
    
    his.hisFindPeriods v => v != null and v > threshold
  end
